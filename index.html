<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sprite to Spritesheet</title>
  <link rel="stylesheet" href="./style.css" />
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
 
  <div class="main">
    <h1>Convert Scratch Sprite to Spritesheet</h1>
    <sub>This is an unofficial tool and is in no way affiliated with Scratch or the Scratch team!</sub>
    <div id="uploads">
      <input type="file" id="spriteUpload" accept=".sprite3" />
      <label for="spriteUpload" id="lFile"></label>
    </div>
    <div id="options">
      <div class="row">
        <p>Images per row:</p> <input type="range" id="rowSlider" class="slider" min="1" max="1" value="1"> <input type="number" id="rowNumber" class="sliderField" value="1">
      </div>
    </div>
    <div class="row">
      <button id="generateSpritesheet" class="grey">Generate Spritesheet</button>
      <a id="downloadLink" download="spritesheet.png" class="grey">Download Spritesheet</a>
    </div>
    <br>
    Preview:
    <canvas id="spritesheetCanvas" width="0" height="0"></canvas>
  </div>

  <script>
    const fileInput = document.getElementById('spriteUpload');
    const generateButton = document.getElementById('generateSpritesheet');
    const canvas = document.getElementById('spritesheetCanvas');
    const ctx = canvas.getContext('2d');
    const downloadLink = document.getElementById('downloadLink');
    const rowInput = document.querySelector("#rowNumber");
    const rowSlider = document.querySelector("#rowSlider");

    ctx.imageSmoothingEnabled = false;
    canvas.style.imageRendering = 'pixelated';

    rowSlider.onchange = (e) => {
      rowInput.value = rowSlider.value;
    };
    rowInput.onchange = (e) => {
      rowSlider.value = Math.max(rowSlider.min, Math.min(rowInput.value, rowSlider.max));
      rowInput.value = rowSlider.value;
    };

    rowSlider.ontouchmove = rowSlider.onchange;
    rowSlider.onmousemove = rowSlider.onchange;

    let spriteJson = null;
    let imagesMap = new Map();

    // Utility: Round to the next power of 2
    const nextPowerOf2 = (num) => Math.pow(2, Math.round(Math.log2(num)));

    // Handle `.sprite3` file upload
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file && file.name.endsWith('.sprite3')) {
        document.querySelector("#lFile").innerHTML = "Processing: " + file.name;
        document.querySelector("#lFile").style.background = "linear-gradient(45deg, #f39c12, #f1c40f)";

        try {
          const zip = new JSZip();
          const zipContent = await zip.loadAsync(file);

          // Extract `sprite.json`
          const jsonFile = Object.keys(zipContent.files).find(name => name.endsWith('sprite.json'));
          if (!jsonFile) throw new Error("Missing sprite.json in the .sprite3 file.");
          const spriteJsonContent = await zipContent.file(jsonFile).async('string');
          spriteJson = JSON.parse(spriteJsonContent);

          // Extract images
          imagesMap.clear();
          const imageFiles = Object.keys(zipContent.files).filter(name => /\.(png|jpg|jpeg|gif)$/i.test(name));
          for (const imageFile of imageFiles) {
            const blob = await zipContent.file(imageFile).async('blob');
            const img = new Image();
            img.src = URL.createObjectURL(blob);
            await img.decode();
            imagesMap.set(imageFile, img);
          }

          document.querySelector("#lFile").innerHTML = `Loaded: ${file.name} (${imageFiles.length} images)`;
          document.querySelector("#lFile").style.padding = "2vh";
          document.querySelector("#lFile").style.color = "white";
          document.querySelector("#lFile").style.border = "0.4vh solid black";
          document.querySelector("#lFile").style.background = "linear-gradient(45deg, #56ab2f, #a8e063)";
          rowSlider.max = spriteJson.costumes.length;
          rowSlider.value = rowSlider.max;
          rowSlider.onchange();
          generateButton.classList = "";
        } catch (error) {
          document.querySelector("#lFile").innerHTML = "Error: " + error.message;
          document.querySelector("#lFile").style.color = "white";
          document.querySelector("#lFile").style.background = "linear-gradient(45deg, #e74c3c, #c0392b)";
          document.querySelector("#lFile").style.padding = "2vh";
          document.querySelector("#lFile").style.border = "0.4vh solid black";
          alert("Error processing sprite: " + error.message);
          console.log("Error processing sprite: " + error.message);
        }
      } else {
        document.querySelector("#lFile").innerHTML = "Not a sprite!";
        document.querySelector("#lFile").style.color = "white";
        document.querySelector("#lFile").style.border = "0.4vh solid black";
        document.querySelector("#lFile").style.padding = "2vh";
        document.querySelector("#lFile").style.background = "linear-gradient(45deg, #dd4433, #881100)";
      }
    });

    // Generate spritesheet
    generateButton.addEventListener('click', () => {
      if (!spriteJson || imagesMap.size === 0) {
        alert('Please upload a .sprite3 file containing both sprite JSON and costume images.');
        return;
      }

      const imgsPerRow = rowInput.value;
      const costumes = spriteJson.costumes;

      let maxWidth = 0;
      let maxHeight = 0;

      // Calculate max dimensions
      const imagesData = costumes.map(costume => {
        const img = imagesMap.get(costume.md5ext);
        if (!img) {
          alert(`Image ${costume.md5ext} not found.`);
          return null;
        }
        maxWidth = Math.max(maxWidth, img.width);
        maxHeight = Math.max(maxHeight, img.height);
        return {
          img,
          scaledWidth: img.width,
          scaledHeight: img.height,
          rotationCenterX: costume.rotationCenterX,
          rotationCenterY: costume.rotationCenterY
        };
      });

      if (imagesData.includes(null)) return;

      const fixedWidth = nextPowerOf2(maxWidth);
      const fixedHeight = nextPowerOf2(maxHeight);

      canvas.width = fixedWidth * imgsPerRow;
      canvas.height = fixedHeight * Math.ceil(costumes.length / imgsPerRow);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let xOffset = 0;
      let yOffset = 0;
      imagesData.forEach(({ img, scaledWidth, scaledHeight, rotationCenterX, rotationCenterY }) => {
        const offsetX = xOffset + (fixedWidth / 2 - rotationCenterX);
        const offsetY = yOffset + (fixedHeight / 2 - rotationCenterY);
        ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
        xOffset += fixedWidth;
        if (xOffset >= canvas.width) {
          xOffset = 0;
          yOffset += fixedHeight;
        }
      });

      // Generate download link
      canvas.toBlob(blob => {
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.download = 'spritesheet.png';
        downloadLink.style.display = 'block';
        downloadLink.textContent = 'Download Spritesheet';
        downloadLink.classList = "";
      }, 'image/png');
    });
  </script>
</body>

</html>